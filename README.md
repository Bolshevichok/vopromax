# Документация виртуального помощника студента ТюмГУ

## Требования к функционалу проекта
 * **Обработка и отправка сообщений в чат-ботах:**
   * в параллельном режиме через Webhook API должен работать чат-бот в MAX;
   * перед началом работы пользователь должен быть уведомлен об использовании ИИ для генерации ответов и обработке персональных данных;
   * параметры подключения к Webhook API MAX указываются в переменных окружения.
 * **Предоставление справочной информации из структуры корпоративной вики-системы:**
   * по запросу пользователя чат-бот должен отправлять справочное меню, повторяющее структуру страниц основного пространства корпоративной вики-системы, имеющих тег (метку) «справка»;
   * если выбранная пользователем чат-бота страница содержит дочерние, вывести меню с дочерними страницами, иначе – текст страницы, включая параграфы, нумерованные и маркированные списки;
   * кодовое название основного пространства Confluence указывается в переменных окружения.
 * **Ответ на произвольные вопросы студентов с опорой на документы из корпоративной вики-системы:**
   * генерировать ответ на сообщение (вопрос) пользователя необходимо в случае, если выполняются все условия:
     * сообщение не соответствует командам чат-бота,
     * в сообщении больше 3 символов,
     * за последнюю минуту пользователь задал менее 5 вопросов;
   * при генерации ответов необходимо опираться на текст (фрагмент текста) документа из корпоративной вики-системы, в котором может быть ответ на вопрос пользователя, при этом документ не должен иметь дочерних страниц, в противном случае он является навигационным и не содержит полезных сведений;
   * документ вики-системы может представлять собой как HTML-страницу, так и PDF-файл с текстовым слоем;
   * допускается создание отдельного поискового хранилища текстов (фрагментов текстов) документов из вики-системы с частотой обновления не более 24 часов;
   * если ответа на вопрос пользователя нет, необходимо отправить пользователю сообщение с просьбой переформулировать вопрос или задать другой;
   * сообщение с ответом на вопрос должно содержать ссылку на источник в корпоративной вики-системе;
   * в случае получения ответа на вопрос, пользователю необходимо предложить оценить ответ: нравится/не нравится;
   * если генерация ответа в среднем занимает больше секунды, необходимо отправить пользователю сообщение с предупреждением о задержке, пока не будет готов ответ;
   * параметры подключения к сервису генеративной модели и корпоративной вики-системе указываются в переменных окружения.
 * **Накопление данных о пользователях и вопросах для последующей обработки:**
   * в базе данных должны храниться сведения о пользователях:
     * ID MAX,
   * в базе данных должны храниться сведения о заданных вопросах и полученных ответах:
     * текст вопроса,
     * текст ответа, если ответ не найден – пустая строка,
     * ссылка на источник в вики-системе, если ответ не найден – NULL,
     * оценка пользователя;
   * все записи в БД должны иметь поля времени создания и обновления.

## Архитектура приложения

![Рис. 1. Архитектура приложения](images/architecture.png)
*Рис. 1.* Архитектура приложения

Архитектура приложения (рис. 1) состоит из трёх составляющих: [микросервис работы с Webhook API чат-бота MAX (Chatbot)](chatbot.md), [микросервис ответа на вопрос по документам (QA)](qa.md), база данных. Каждая составляющая вынесена в отдельный Docker-контейнер.

Chatbot взаимодействует с API [вики-системы Confluence](confluence-integration.md) для получения справочной информации и Webhook API MAX. QA взаимодействует с API вики-системы Confluence для получения документов при формировании векторного хранилища документов и API большой языковой модели Mistral для генерации ответов.

> [!IMPORTANT]
> В отдельный Docker-контейнер `db-migrate` вынесен сервис создания миграций баз данных. Синхронизация между базой данных и моделями ORM микросервисов должна осуществляться путём [миграций](https://alembic.sqlalchemy.org/en/latest/ops.html).

## Минимальные системные требования
 * OS с предустановленными Docker, Docker compose
 * CPU: 2 GHz, 2 ядра
 * RAM: 6 GB
 * Disk: 20 GB

## Переменные среды
Пример файла с переменными среды представлен в [.env.example](.env.example) в корне репозитория.

## Сборка и запуск проекта
```bash
docker compose --env-file .env.docker up -d --build
```

## См. также
1. [Микросервис Chatbot](chatbot.md)
2. [Микросервис QA](qa.md)


# Микросервис Chatbot

## Описание
Микросервис, обрабатывающий LongPoll API-запросы чат-ботов VK и Telegram.

> [!IMPORTANT]
> Информация о настройке взаимодействия с вики-системой Confluence представлена в [confluence-integration.md](confluence-integration.md).

## [main](chatbot/main.py)

### `vk_keyboard_choice(notify_text: str) -> str`
Возвращает клавиатуру из кнопок предоставления справочной информации и подписки на рассылку (если пользователь подписан, то отписки от неё) для чат-бота ВКонтакте

    Args:
        notify_text (str): "Подписаться на рассылку" если пользователь не подписан, иначе "Отписаться от рассылки"

    Returns:
        str: JSON-объект, описывающий клавиатуру с шаблонами сообщений


## [database](chatbot/database.py)
### `class User(Base)`
Пользователь чат-бота

    Args:
        id (int): id пользователя
        max_id (int): id пользователя MAX
        is_subscribed (bool): состояние подписки пользователя
        question_answers (List[QuestionAnswer]): вопросы пользователя
        created_at (datetime): время создания модели
        updated_at (datetime): время обновления модели

### `class QuestionAnswer(Base)`
Вопрос пользователя с ответом на него

    Args:
        id (int): id ответа
        question (str): вопрос пользователя
        answer (str | None): ответ на вопрос пользователя
        confluence_url (str | None): ссылка на страницу в вики-системе, содержащую ответ
        score (int | None): оценка пользователем ответа
        user_id (int): id пользователя, задавшего вопрос
        user (User): пользователь, задавший вопрос
        created_at (datetime): время создания модели
        updated_at (datetime): время обновления модели

### `add_user(engine: Engine, max_id: int | None = None) -> tuple[bool, int]`
Функция добавления в БД пользователя виртуального помощника

    Args:
        engine (Engine): подключение к БД
        max_id: int | None = None: id пользователя MAX

    Returns:
        tuple[bool, int]: добавился пользователь или нет, какой у него id в БД

### `get_user_id(engine: Engine, max_id: int | None = None) -> int | None`
Функция получения из БД пользователя

    Args:
        engine (Engine): подключение к БД
        max_id (int | None): id пользователя МАХ

    Returns:
        int | None: id пользователя или None

### `subscribe_user(engine: Engine, user_id: int) -> bool`
Функция оформления подписки пользователя на рассылку

    Args:
        engine (Engine): подключение к БД
        user_id (int): id пользователя

    Returns:
        bool: подписан пользователь или нет

### `check_spam(engine: Engine, user_id: int) -> bool`
Функция проверки на спам

    Args:
        engine (Engine): подключение к БД
        user_id (int): id пользователя

    Returns:
        bool: пользователь задал пять вопросов за последнюю минуту

### `add_question_answer(engine: Engine, question: str, answer: str, confluence_url: str | None, user_id: int) -> int`
Функция добавления в БД вопроса пользователя с ответом на него

    Args:
        engine (Engine): подключение к БД
        question (str): вопрос пользователя
        answer (str): ответ на вопрос пользователя
        confluence_url (str | None): ссылка на страницу в вики-системе, содержащую ответ
        user_id (int): id пользователя

    Returns:
        int: id вопроса с ответом на него

### `rate_answer(engine: Engine, question_answer_id: int, score: int) -> bool`
Функция оценивания ответа на вопрос

    Args:
        engine (Engine): подключение к БД
        question_answer_id (int): id вопроса с ответом
        score (int): оценка ответа

    Returns:
        bool: удалось добавить в БД оценку ответа или нет


# Микросервис QA

## Описание
Микросервис, предоставляющий API для:
 * генерации ответа на вопрос, опираясь на документы из вики-системы;
 * обновления векторного индекса текстов документов из вики-системы.

## [main](qa/main.py)

### `get_answer(context: str, question: str) -> str`
Возвращает сгенерированный LLM ответ на вопрос пользователя по заданному документу в соответствии с промтом

    Args:
        context (str): текст документа (или фрагмента документа)
        question (str): вопрос пользователя

    Returns:
        str: экземпляр класса Chunk — фрагмент документа

### `qa(request: web.Request) -> web.Response`
Возвращает ответ на вопрос пользователя и ссылку на источник

    Args:
        request (web.Request): запрос, содержащий `question`

    Returns:
        web.Response: ответ

### `reindex(request: web.Request) -> web.Response`
Пересоздаёт векторный индекс текстов для ответов на вопросы

    Args:
        request (web.Request): запрос

    Returns:
        web.Response: ответ

## [config](qa/config.py)

### `class Config`
Класс с переменными окружения

#### `get_mistral_headers() -> dict`
Возвращает заголовки для запросов к Mistral API

#### `get_default_prompt(context: str, question: str)`
Создаёт payload с промптом для Mistral API

## [database](qa/database.py)

### `class Chunk(Base)`
Фрагмент документа из вики-системы

    Args:
        confluence_url (str): ссылка на источник
        text (str): текст фрагмента
        embedding (Vector): векторное представление текста фрагмента размерностью 1024
        created_at (datetime): время создания модели
        updated_at (datetime): время обновления модели

## [confluence_retrieving](qa/confluence_retrieving.py)

### `get_document_content_by_id(confluence: Confluence, page_id: str) -> tuple[str | None, str | None]`
Возвращает содержимое страницы на Confluence после предобработки с помощью PyPDF или BS4 и ссылку на страницу

    Args:
        confluence (Confluence): экземпляр Confluence
        page_id (str): ID страницы

    Returns:
        tuple[str | None, str | None]: содержимое страницы, ссылка на страницу

### `reindex_confluence(engine: Engine, text_splitter: TextSplitter, encoder_model: SentenceTransformer)`
Пересоздаёт векторный индекс текстов для ответов на вопросы. При этом обрабатываются страницы, не имеющие вложенных страниц.

    Args:
        engine (Engine): экземпляр подключения к БД
        text_splitter (TextSplitter): разделитель текста на фрагменты
        encoder_model (SentenceTransformer): модель получения векторных представлений Sentence Transformer

### `get_chunk(engine: Engine, encoder_model: SentenceTransformer, question: str) -> Chunk | None`
Возвращает ближайший к вопросу фрагмент документа Chunk из векторной базы данных

    Args:
        engine (Engine): экземпляр подключения к БД
        encoder_model (SentenceTransformer): модель получения векторных представлений SentenceTransformer
        question (str): вопрос пользователя

    Returns:
        Chunk | None: экземпляр класса Chunk — фрагмент документа
